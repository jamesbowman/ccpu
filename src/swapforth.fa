\ The definition starts with "CODE" and the word name
\
\ Every definition should call DORETURN - this
\ should appear early for maximum overlap.
\
\ Definitions the only use port-execution are
\ shortest - they have only a prefix.
\
\ Definitions that need labels (i.e. "if" and
\ "next" targets) will actually be loaded into node
\ RAM.  The load pump leaves A on the stack, so in
\ this case the prefix must start with "a!". The
\ jump/call from the prefix into RAM is explicit,
\ e.g. "jump main". So a common pattern is:
\
\     CODE fancyword
\       a! call DORETURN
\       call main
\
\     : main
\       ...
\       ;
\
\ Permanent subroutines (see nt.ga for source):
\   -!        push T onto the D stack
\   LIT       push literal, usage "@p call LIT"
\   GO        tell R to request next fragment T
\   DORETURN  tell R to request next fragment from R stack
\   TO_R      push T on R
\
\ Do this to run:
\
\   python fa.py swapforth.fa           # assemble this file into "image", listing "lst"
\   python flash.py $PORT write image   # write "image" to flash
\   python asm.py $PORT nt.ga           # bootstrap, dump results of running "boot" word
\

CODE true
  call DORETURN
  call -!
  @p
    -1

CODE false
  call DORETURN
  call -!
  dup or

CODE 1+
  call DORETURN
  @p . +
    1

CODE 1-
  call DORETURN
  @p . +
    -1

CODE negate
  call DORETURN
  - @p . +
    1

CODE abs
  call DORETURN
  dup call 18shr    \ x m
  over over . +     \ x m x+m
  or                \ x (x+m)^m

CODE invert
  - call DORETURN

CODE emit
  call DORETURN
  a over @p
    EAST
  a! ! a!
  @+

CODE +
  call DORETURN
  @+ . +

CODE -
  call DORETURN
  @+ - . +
  -

CODE and
  call DORETURN
  @+ and

CODE or
  call DORETURN
  @+ over -
  and or

CODE xor
  call DORETURN
  @+ or

CODE lshift
  a! call DORETURN
  push @+
  next lshift
: lshift
  2* unext
  jump NORTH

CODE rshift
  a! call DORETURN
  call NORTH          \ so body code can use ';'
  push @+
  next main
: main
  -if pos
  2/ @p and
    0x1ffff
  next pos
  ;
: pos
  2/ unext ;

CODE *
  @+ call DORETURN
  a push a!
  @p @p push
    0
    17
  +* unext a
  pop a!

CODE um*
  a! call DORETURN
  @ a push
  call main
  pop a! !
: main
  over a! @p @p
    0
    8
  push
  +* . +* unext 
  push -if L1
  drop pop . +
  a ;
: L1
  drop drop pop
  a ;

CODE m*
  @ call DORETURN
  a push dup
  call 18shr
  push a! dup dup
  or @p push
    8
  +* . +* unext
  - over pop
  and . +
  - a pop
  a! !

CODE um/mod
  - @p . +
    1
  push call DORETURN
  @+ @ pop
  a push
  call --u/mod
  pop a!
  over !

CODE execute
  @+ over
  call GO

CODE rot
  call DORETURN
  a push
  @ over !+
  @ over !
  pop a!

CODE drop
  @+ call DORETURN

CODE dup
  dup call -!
  call DORETURN

CODE over
  @ over
  call -!
  call DORETURN

CODE swap
  @ over !
  call DORETURN

CODE snap
  a! jump main
: main
  a push
  @p a! !
    EAST
  pop a!
  @+
  jump main

CODE 0<>
  a! call DORETURN
  call main
: main
  dup dup or
  over if is0
  drop - ;
: is0
  drop ;

CODE 0=
  dup call DORETURN
  - @p . +
    1
  or -
  call 18shr

CODE 0<
  call DORETURN
  call 18shr

CODE <>
  a! call DORETURN
  call main
: main
  dup dup or
  over @+ or
  if is0
  drop - ;
: is0
  drop ;

CODE =
  a! call DORETURN
  call main
: main
  dup dup or
  over @+ or
  if is0
  drop ;
: is0
  drop - ;

CODE depth
  call -!
  a call DORETURN
  - @p . +
    STACKTOP

CODE pick
  call DORETURN
  a dup push +
  a! @ pop
  a!   

\ ====================================================
\ external RAM
\ ====================================================

CODE @
  a call DORETURN
  push @p a! @p
    SOUTH
    call 506.@
  ! ! @
  pop a!

CODE !
  @+ call DORETURN
  a push @p
    SOUTH
  a! over @p
    call 506.!
  ! ! !
  pop a! @+

CODE c@
  a call DORETURN
  push @p a! @p
    SOUTH
    call 506.c@
  ! ! @
  pop a!

CODE 1-dup
  call DORETURN
  @p . +
    -1
  dup call -!

%FORTHLIKE%

\ ====================================================
\ CORE words
\ ====================================================

: 2dup
  over over ;

: 0>
  dup 0< invert swap 0<> and ;

: -rot
  rot rot ;

: sgn ( u1 n1 -- n2 ) \ n2 is u1 with the sign of n1
    0< if negate then
;

\ Divide d1 by n1, giving the symmetric quotient n3 and the remainder
\ n2.
\ : sm/rem ( d1 n1 -- n2 n3 )
\     2dup xor >r     \ combined sign, for quotient
\     over >r         \ sign of dividend, for remainder
\     abs >r dabs r>
\     um/mod          ( remainder quotient )
\     swap r> sgn     \ apply to remainder
\     swap r> sgn     \ apply to quotient
\ ;

\ Divide d1 by n1, giving the floored quotient n3 and the remainder n2.
\ Adapted from hForth
\ : fm/mod ( d1 n1 -- n2 n3 )
\     dup >r 2dup xor >r
\     >r dabs r@ abs
\     um/mod
\     r> 0< if
\         swap negate swap
\     then
\     r> 0< if
\         negate         \ negative quotient
\         over if
\             r@ rot - swap 1-
\         then
\     then
\     r> drop
\ ;
\ 
\ : */mod     >r m* r> sm/rem ;
\ : */        */mod nip ;

\ ====================================================
\ testing
\ ====================================================

: memtest

  0x4142 256 !
  0x4443 0 !
  1 c@
  0 c@
  256 c@
  257 c@
;

: perf          \ Takes .714 s
  0xaaaa emit
  10000
  begin
    1- dup 0=
  until
  0xbbbb emit
;

: boot
  100 200 300 
  
  \ memtest
  snap ;
