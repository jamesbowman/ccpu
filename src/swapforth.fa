\ The definition starts with "CODE" and the word name
\
\ Every definition should call DORETURN - this
\ should appear early for maximum overlap.
\
\ Definitions the only use port-execution are
\ shortest - they have only a prefix.
\
\ Definitions that need labels (i.e. "if" and
\ "next" targets) will actually be loaded into node
\ RAM.  The load pump leaves A on the stack, so in
\ this case the prefix must start with "a!". The
\ jump/call from the prefix into RAM is explicit,
\ e.g. "jump main". So a common pattern is:
\
\     CODE fancyword
\       a! call DORETURN
\       call main
\
\     : main
\       ...
\       ;
\
\ Permanent subroutines (see nt.ga for source):
\   -!        push T onto the D stack
\   LIT       push literal, usage "@p call LIT"
\   GO        tell R to request next fragment T
\   DORETURN  tell R to request next fragment from R stack
\   TO_R      push T on R
\
\ Do this to run:
\
\   python fa.py swapforth.fa           # assemble this file into "image", listing "lst"
\   python flash.py $PORT write image   # write "image" to flash
\   python asm.py $PORT nt.ga           # bootstrap, dump results of running "boot" word
\

CODE >r
  @p !b @b
    @+ !p
  over call TO_R
  @+ over
  call GO

CODE r@
  call -!
  @p !b @b
    @+ !p
  @p !b @b
    @ !p
  over call GO

CODE r>
  call -!
  @p !b @b
    @+ !p
  @p !b @b
    @+ !p
  over call GO

CODE 2>r
  @p !b @b
    @+ !p
  @+ call TO_R
  over call TO_R
  @+ over
  call GO

CODE 2r>
  @p !b @b
    @+ !p
  push
  call -!
  @p !b @b
    @+ !p
  call -!
  @p !b @b
    @+ !p
  @ over !
  pop call GO

CODE true           #returns #inline
  call -!
  @p
    -1

CODE false          #returns #inline
  call -!
  dup or

CODE 1+             #returns #inline
  @p . +
    1

CODE 1-             #returns #inline
  @p . +
    -1

CODE negate         #returns #inline
  - @p . +
    1

CODE abs            #returns #inline
  dup call 18shr    \ x m
  over over . +     \ x m x+m
  or                \ x (x+m)^m

CODE invert         #returns #inline
  -

CODE 2*             #returns #inline
  2*

CODE 2/             #returns #inline
  2/

CODE emit
  call DORETURN
  a over @p
    EAST
  a! @p !
   1
  ! a! @+

\ CODE wait
\   @+ a push @p
\      EAST
\   a! @p !
\      2
\   over ! !
\   @ pop a!
\  call DORETURN

CODE sleep
  a @p a! @p
    EAST
    2
  ! dup !
  over ! @
  drop a! @+
 call DORETURN

CODE +              #returns #inline
  @+ . +

CODE -              #returns #inline
  @+ - . +
  -

CODE and            #returns #inline
  @+ and

CODE or             #returns #inline
  @+ over -
  and or

CODE xor            #returns #inline
  @+ or

CODE lshift         #returns
  a!  push @+
  next lshift
: lshift
  2* unext
  jump NORTH

CODE rshift         #returns
  a!
  call NORTH          \ so body code can use ';'
  push @+
  next main
: main
  -if pos
  2/ @p and
    0x1ffff
  next pos
  ;
: pos
  2/ unext ;

CODE *              #returns #inline
  @+
  a push a!
  @p @p push
    0
    17
  +* unext a
  pop a!

CODE um*
  a! call DORETURN
  @ a push
  call main
  pop a! !
: main
  over a! @p @p
    0
    8
  push
  +* . +* unext 
  push -if L1
  drop pop . +
  a ;
: L1
  drop drop pop
  a ;

CODE m*
  @ call DORETURN
  a push dup
  call 18shr
  push a! dup dup
  or @p push
    8
  +* . +* unext
  - over pop
  and . +
  - a pop
  a! !

CODE um/mod
  - @p . +
    1
  push call DORETURN
  @+ @ pop
  a push
  call --u/mod
  pop a!
  over !

CODE execute
  @+ over
  call GO

CODE rot            #returns #inline
  a push
  @ over !+
  @ over !
  pop a!

CODE drop           #returns #inline
  @+

CODE 2drop          #returns #inline
  @+ @+

CODE nip            #returns #inline
  @+ drop

CODE tuck           #returns #inline
  @ over dup
  ! over
  call -!

CODE dup            #returns #inline
  dup call -!

CODE over           #returns #inline
  @ over
  call -!

CODE swap           #returns #inline
  @ over !

CODE snap
  a! jump main
: main
  a over @p
    EAST
  a! @p !
   1
  ! a! @+
  jump main

CODE 0<>            #returns #inline
  dup
  - @p . +
    1
  or call 18shr

CODE 0=             #returns #inline
  dup @p . +
    -1
  over - and
  call 18shr

CODE 0<             #returns #inline
  call 18shr

CODE <>             #returns #inline
  @+ or dup
  - @p . +
    1
  or call 18shr

CODE =              #returns #inline
  @+ or
  dup @p . +
    -1
  over - and
  call 18shr

CODE depth          #returns #inline
  call -!
  a
  - @p . +
    STACKTOP

CODE <              #returns #inline
  @+ over over
  or - 2/
  push - and
  pop . +
  - call 18shr

CODE >              #returns #inline
  push @+ pop
  over over or
  - 2/ push
  - and pop .
  + -
  call 18shr

CODE u<             #returns #inline
  @+
  over over or
  dup push
  - 2/ push
  - and pop .
  + - pop
  or call 18shr

CODE u>             #returns #inline
  @+ over over
  over or dup
  push - 2/
  push - and
  pop . +
  - pop or
  call 18shr

CODE d+             #returns #inline
  call 0x200|NORTH
  call clc
  @+ @+               
  a push @           ( ah al bh bl )

  a! push a .
  + a! pop .
  + a

  pop a! ! ;

CODE pick          #returns #inline
  a dup push +
  a! @ pop
  a!   

CODE ni
  call DORETURN
  call -!
  pop dup push
  
\ : sgn ( u1 n1 -- n2 ) \ n2 is u1 with the sign of n1
CODE sgn            #returns #inline
  @p and @+ @p
    0x20000
    0x1ffff
  and or

\ ====================================================
\ external RAM
\ ====================================================

CODE @              #inline #returns
  a
  push @p a! @p
    SOUTH
    call 506.@
  ! ! @
  pop a!

CODE !              #inline #returns
  @+
  a push @p
    SOUTH
  a! over @p
    call 506.!
  ! ! !
  pop a! @+

CODE c@
  a call DORETURN
  push @p a! @p
    SOUTH
    call 506.c@
  ! ! @
  pop a!

\ display control
\ ====================================================
CODE new
  @p @p !b    \set a
     EAST     \west in 605
     a @p a!
  !b dup dup
  or @p !b    \send 0
     @p !
  !b @p !b    \send arg1
     @p ! @p
  !b @+ !b @p \send arg2
     ! @ !p   \read return val
  !b @b @p    \reset a
     a!
  !b
  call DORETURN

CODE update
  @p @p !b
     EAST
     a @p a!
  !b @p !b @p
     @p !
     4
  !b @p !b
     @ !p a!
  @b drop
  call DORETURN

%FORTHLIKE%

\ ====================================================
\ CORE words
\ ====================================================

: +!
  tuck @ + swap ! ;

: 2dup
  over over ;

: 0>
  dup 0< invert swap 0<> and ;

: -rot
  rot rot ;


: dnegate
    invert swap invert swap
    1. d+
;

: dabs
    dup 0< if dnegate then
;

: s>d   dup 0< ;
: d>s   drop ;

: d=                        \ a b c d -- f )
    rot =                   \ a c b=d
    >r = r>                 \ a=c b=d
    and
;

: d<            \ ( al ah bl bh -- flag )
    rot         \ al bl bh ah
    2dup =
    if
        2drop u<
    else
        > nip nip
    then
;

: du<           \ ( al ah bl bh -- flag )
    rot         \ al bl bh ah
    2dup =
    if
        2drop u<
    else
        u> nip nip
    then
;

: d-
    dnegate d+
;

: d0<
    nip 0<
;

: d0=
    or 0=
;

: d2*
    2dup d+
;

: d2/
    >r 1 rshift r@
    17 lshift
    or r> 2/
;

\ Divide d1 by n1, giving the symmetric quotient n3 and the remainder
\ n2.
: sm/rem ( d1 n1 -- n2 n3 )
    2dup xor >r     \ combined sign, for quotient
    over >r         \ sign of dividend, for remainder
    abs >r dabs r>
    um/mod          ( remainder quotient )
    swap r> sgn     \ apply to remainder
    swap r> sgn     \ apply to quotient
;

\ Divide d1 by n1, giving the floored quotient n3 and the remainder n2.
\ Adapted from hForth
: fm/mod ( d1 n1 -- n2 n3 )
    dup >r 2dup xor >r
    >r dabs r@ abs
    um/mod
    r> 0< if
        swap negate swap
    then
    r> 0< if
        negate         \ negative quotient
        over if
            r@ rot - swap 1-
        then
    then
    r> drop
;

: */mod     >r m* r> sm/rem ;
: */        */mod nip ;

: /mod      >r s>d r> sm/rem ;
: /         /mod nip ;
: mod       >r s>d r> sm/rem drop ;

\ From Wil Baden's "FPH Popular Extensions"
\ http://www.wilbaden.com/neil_bawd/fphpop.txt

: tnegate                           ( t . . -- -t . . )
    >r  2dup or dup if drop  dnegate 1  then
    r> +  negate ;

: t*                                ( d . n -- t . . )
                                    ( d0 d1 n)
    2dup xor >r                     ( r: sign)
    >r dabs r> abs
    2>r                             ( d0)( r: sign d1 n)
    r@ um* 0                        ( t0 d1 0)
    2r> um*                         ( t0 d1 0 d1*n .)( r: sign)
    d+                              ( t0 t1 t2)
    r> 0< if tnegate then ;

: t/                                ( t . . u -- d . )
                                    ( t0 t1 t2 u)
    over >r >r                      ( t0 t1 t2)( r: t2 u)
    dup 0< if tnegate then
    r@ um/mod                       ( t0 rem d1)
    rot rot                         ( d1 t0 rem)
    r> um/mod                       ( d1 rem' d0)( r: t2)
    nip swap                        ( d0 d1)
    r> 0< if dnegate then ;

: m*/  ( d . n u -- d . )
    >r t*  r> t/ ;

: bounds
  over + swap ;

\ ====================================================
\ testing
\ ====================================================

: hex1
  15 and dup 10 u< if then
;

: memtest

  0x4142 256 !
  0x4443 0 !
  1 c@
  0 c@
  256 c@
  257 c@
;

: perf          \ Takes .266 s
  0xaaaa emit
  10000
  begin
    1- dup 0=
  until drop
  0xbbbb emit
;

: perf2
  0xaaaa emit
  1000 for 1000 for 0 drop next next
  0xbbbb emit
;

: bench
  50000 0 do
    i 7 mod drop
  loop ;

: doubles
  1 swap
  begin
    swap 2* swap
    1- dup 0=
  until
  drop
;

: fib ( u -- u )
  1 1 rot for
    tuck +
  next
  ;

include(easter.fs)

: boot
  100 200 300

  110 100
  begin
    2dup <>
  while
    dup emit 1+
  repeat
  
\ \ 10000000000. 104348 33215 m*/

\ \ memtest
\ \ 0x123456789. 0x121212121.  d+
\ \ 0 begin
\ \   dup 0x1000 u> emit
\ \   0x1000 +
\ \ dup 0= until
\ \ drop

\ perf2
\  2 sleep

  0xcccc emit
  bench
  0xcccc emit

  2017 easter
  snap ;
